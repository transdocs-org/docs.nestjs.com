### 请求生命周期

Nest 应用程序通过我们称之为 **请求生命周期** 的一系列顺序来处理请求并生成响应。由于使用了中间件、管道、守卫和拦截器，要追踪特定代码在请求生命周期中的执行位置可能会变得复杂，尤其是在使用全局、控制器级别和路由级别的组件时。总体而言，一个请求会依次经过中间件 → 守卫 → 拦截器 → 管道，最终在生成响应时再返回到拦截器。

#### 中间件

中间件会按照特定的顺序执行。首先，Nest 会运行全局绑定的中间件（例如使用 `app.use` 绑定的中间件），然后运行[模块绑定的中间件](/middleware)，这些中间件根据路径来确定。中间件按照绑定顺序依次执行，这与 Express 中的中间件执行方式类似。当在不同模块中绑定中间件时，根模块绑定的中间件会最先执行，之后中间件的执行顺序与模块在 `imports` 数组中添加的顺序一致。

#### 守卫

守卫的执行顺序首先是全局守卫，接着是控制器守卫，最后是路由守卫。和中间件一样，守卫也按照绑定顺序依次执行。例如：

```typescript
@UseGuards(Guard1, Guard2)
@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}

  @UseGuards(Guard3)
  @Get()
  getCats(): Cats[] {
    return this.catsService.getCats();
  }
}
```

`Guard1` 会在 `Guard2` 之前执行，而 `Guard2` 又会在 `Guard3` 之前执行。

> info **提示** 当我们提到全局绑定与控制器或局部绑定的区别时，关键在于守卫（或其他组件）绑定的位置。如果你使用 `app.useGlobalGuard()` 或通过模块提供组件，则该组件是全局绑定的。否则，如果装饰器位于控制器类之前，则绑定到控制器；如果装饰器位于路由声明之前，则绑定到路由。

#### 拦截器

拦截器的执行模式与守卫基本相同，但有一个关键点：由于拦截器返回的是 [RxJS Observables](https://github.com/ReactiveX/rxjs)，这些 Observable 会以先进后出的方式解析。因此，进入请求会按照全局 → 控制器 → 路由的顺序处理，而响应（即控制器方法处理完成后）则会从路由 → 控制器 → 全局的顺序处理。此外，管道、控制器或服务中抛出的任何错误都可以在拦截器的 `catchError` 操作符中捕获。

#### 管道

管道的执行顺序也是从全局到控制器再到路由，并且 `@UsePipes()` 参数的执行顺序是先进先出。然而，在路由参数级别，如果有多个管道同时运行，它们会按照最后一个带有管道的参数到第一个参数的顺序执行。这同样适用于路由级别和控制器级别的管道。例如，如果我们有以下控制器：

```typescript
@UsePipes(GeneralValidationPipe)
@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}

  @UsePipes(RouteSpecificPipe)
  @Patch(':id')
  updateCat(
    @Body() body: UpdateCatDTO,
    @Param() params: UpdateCatParams,
    @Query() query: UpdateCatQuery,
  ) {
    return this.catsService.updateCat(body, params, query);
  }
}
```

那么 `GeneralValidationPipe` 会依次作用于 `query`、`params` 和 `body` 对象，之后才会运行 `RouteSpecificPipe`，其顺序也是一致的。如果有任何参数级别的管道，它们也会在控制器和路由级别的管道之后运行（同样是从最后一个参数到第一个参数的顺序）。

#### 过滤器

过滤器是唯一一个不优先解析全局组件的机制。相反，过滤器会从最低级别开始解析，即执行顺序是路由绑定的过滤器 → 控制器级别的过滤器 → 全局过滤器。需要注意的是，异常不会在多个过滤器之间传递；如果一个路由级别的过滤器捕获了异常，控制器或全局级别的过滤器将无法再捕获相同的异常。实现类似效果的唯一方式是在过滤器之间使用继承。

> info **提示** 只有在请求过程中出现未捕获的异常时才会执行过滤器。通过 `try/catch` 捕获的异常不会触发异常过滤器。一旦遇到未捕获的异常，生命周期的其余部分将被跳过，请求会直接进入过滤器。

#### 总结

总的来说，请求生命周期如下所示：

1. 接收到请求
2. 中间件
   - 2.1 全局绑定中间件
   - 2.2 模块绑定中间件
3. 守卫
   - 3.1 全局守卫
   - 3.2 控制器守卫
   - 3.3 路由守卫
4. 拦截器（控制器前）
   - 4.1 全局拦截器
   - 4.2 控制器拦截器
   - 4.3 路由拦截器
5. 管道
   - 5.1 全局管道
   - 5.2 控制器管道
   - 5.3 路由管道
   - 5.4 路由参数管道
6. 控制器（方法处理器）
7. 服务（如果存在）
8. 拦截器（请求后）
   - 8.1 路由拦截器
   - 8.2 控制器拦截器
   - 8.3 全局拦截器
9. 异常过滤器
   - 9.1 路由级别
   - 9.2 控制器级别
   - 9.3 全局级别
10. 服务器响应